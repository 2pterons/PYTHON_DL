# -*- coding: utf-8 -*-
"""6-5.book.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KSt0Es7toh3HSOEPRv6H5NYjfyWam1rj
"""

# 도서 추천시스템 (Book Recommendation System) : 행렬 분해를 이용한 잠재 요인 협업 필터링 사용
# Keras Embedding layer를 적용한다.
import pandas as pd
import numpy as np
from sklearn.metrics import mean_squared_error
from tensorflow.keras.layers import Input, Dense, Dropout, Embedding
from tensorflow.keras.layers import Flatten, Dot, Activation
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
import tensorflow.keras.backend as K
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder

# Commented out IPython magic to ensure Python compatibility.
# 학습 데이터를 읽어온다.
# 데이터 url : https://www.kaggle.com/arashnic/book-recommendation-dataset
# %cd '/content/drive/My Drive/Colab Notebooks'
books = pd.read_csv('data/book/Books.csv')
ratings = pd.read_csv('data/book/Ratings.csv')

books = books[['ISBN', 'Book-Title', 'Image-URL-M']]

df = pd.merge(ratings, books, on='ISBN')
df = df.drop_duplicates(['User-ID', 'ISBN'])
df = df.drop_duplicates(['User-ID', 'Book-Title'])

# User-ID와 ISBN가 중간에 빈 값이 많으므로 순차적인 id를 다시 부여한다.
user_enc = LabelEncoder()
item_enc = LabelEncoder()

df['userId'] = user_enc.fit_transform(df['User-ID'])
df['itemId'] = item_enc.fit_transform(df['ISBN'])
df['rating'] = df['Book-Rating'] / 10.0   # 0 ~ 10.0 --> 0.0 ~ 1.0으로 표준화.

# number of users and items
n_users = df['userId'].max() + 1
n_items = df['itemId'].max() + 1
print(n_users, n_items)

# Ratings (Book-Rating) are either explicit, expressed on a scale from 1-10 
# (higher values denoting higher appreciation), or implicit, expressed by 0.
# explicit : 직접적, 구체적 의사표현 (평점)
# implicit : 간접적 의사표현 (클릭, 구매, 댓글 등)
# rating = 0은 읽은 책이지만 평점을 부여하지 않은 것으로 판단한다.
# 학습에 포함하면 explicitly 0으로 추정할 것이므로 학습에서 제외한다.
# 추천시에는 읽은 책으로 판단하여 추천 대상에서도 제외한다.
explicit = df[df['Book-Rating'] > 0].copy()
implicit = df[df['Book-Rating'] <= 0].copy()


# 5명 이상 읽은 책으로만 학습한다.
value_counts = explicit['ISBN'].value_counts()
to_remove = value_counts[value_counts <= 5].index
explicit = explicit[~explicit['ISBN'].isin(to_remove)]
explicit.shape, implicit.shape

# 학습 데이터와 시험 데이터로 분리
d_train, d_test = train_test_split(explicit, test_size = 0.1)

# 학습 데이터 세트를 생성한다.
x_user_train = np.array(d_train['userId']).reshape(-1, 1)
x_item_train = np.array(d_train['itemId']).reshape(-1, 1)
y_rating_train = np.array(d_train['rating']).reshape(-1, 1)

# 시험 데이터 세트를 생성한다.
x_user_test = np.array(d_test['userId']).reshape(-1, 1)
x_item_test = np.array(d_test['itemId']).reshape(-1, 1)
y_rating_test = np.array(d_test['rating']).reshape(-1, 1)
n_users, n_items

# 출력이 0 ~ 1로 제한된 경우의 regression 문제에 적합한 loss function은 무엇인가?
# 1. sigmoid를 사용하면 x = 0에서 미분값 0.25로 최댓값을 갖기 때문에 w가 많이 업데이트된다.
#    이것은 x = 0, y = 0.5인 지점을 빨리 벗어나려는 것이며, 결과는 0과 1 부근의 값이
#    많이 분포하게 된다. 이런 행태는 classification에 적합하다. Regression에서는 bias가
#    발생한다. (Using sigmoid is not good for regression as it is more biased towards 
#    0 and 1 than the middle values (only good for classification). One should use an 
#    activation function like relu and restrict it to be less than 1
#
#    일반적으로는 위의 내용이 맞지만, 추정 평점의 분포를 확인해서 양쪽으로 bias가 발생하지
#    않는다면 sigmoid를 써도 된다.
#
# 2. hard_sigmoid를 사용하는 방법: sigmoid와 유사함. 계산 속도는 빠름.
#    if x < -2.5: return 0
#    if x > 2.5: return 1
#    if -2.5 <= x <= 2.5: return 0.2 * x + 0.
#
# 3. clip으로 최소, 최댓값을 제한하는 방법 : 경계 지점으로 출력이 몰린다.
# 4. 그냥 linear를 사용하는 방법 : 0과 1을 벗어나는 출력이 발생한다.
def bounded_activation(x):
    # return K.sigmoid(x)
    # return K.hard_sigmoid(x)
    # return K.clip(x, 0, 1.0)
    return x    # linear activation

n_factors = 25
x_input_user = Input(batch_shape = (None, x_user_train.shape[1]))
x_input_item = Input(batch_shape = (None, x_item_train.shape[1]))

x_user_emb = Embedding(input_dim = n_users, output_dim = n_factors)(x_input_user)
x_user_emb = Dropout(0.5)(x_user_emb)
x_user_emb = Flatten()(x_user_emb)

x_item_emb = Embedding(input_dim = n_items, output_dim = n_factors)(x_input_item)
x_item_emb = Dropout(0.5)(x_item_emb)
x_item_emb = Flatten()(x_item_emb)

y_output = Dot(axes=1)([x_user_emb, x_item_emb])
y_output = Activation(bounded_activation)(y_output)
model = Model([x_input_user, x_input_item], y_output)
model.compile(loss='mse', optimizer = Adam(learning_rate=0.001))
model.summary()

# 학습
# hist = model.fit([x_user_train, x_item_train], y_rating_train, 
#                  batch_size=2048, 
#                  epochs = 50,
#                  shuffle = True,
#                  validation_data=([x_user_test, x_item_test], y_rating_test))

# loss 확인
# plt.plot(hist.history['loss'], label='train')
# plt.plot(hist.history['val_loss'], label='test')
# plt.legend()
# plt.show()

# 타겟 유저가 관심을 갖는 책들 (implicit)에 대해 해당 유저가 부여할 rating을 추정한다.
# 두 번째 User-ID = 2313
user_id = user_enc.transform([2313])[0]
top_n = 10          # 추정 평점이 높은 상위 top_n개 추천

# target user가 읽은 책의 itemId
seen_id = set(explicit[explicit['userId'] == user_id]['itemId'])

# target user가 관심을 보였던 itemId
implicit_itemid = set(implicit[implicit['userId'] == user_id]['itemId'])

# seen_id와 implicit_id가 겹치는 게 있는지 확인한다. --> 없다
seen_id & implicit_itemid

# target user가 관심을 보인 영화의 평점을 추정하기 위한 데이터 세트를 생성한다.
x_target_impitem = np.array(list(implicit_itemid), dtype=np.int32)
x_target_user = np.ones(shape = x_target_impitem.shape, dtype=np.int32) * user_id
x_target_impitem.shape, x_target_user.shape

# target user가 관심을 갖는 영화의 평점을 추정한다.
x_target_rating = model.predict([x_target_user, x_target_impitem]).reshape(-1)

# 추정 평점이 높은 상위 10개를 선택한다.
recom_idx = x_target_rating.argsort()[::-1][:top_n]

# 추천 책들의 이미지와 제목을 표시한다.
from urllib.request import urlopen
from PIL import Image, ImageOps

print('\nUser = {}의 관심 대상 추천 도서 목록 top-{}:\n'.format(user_enc.inverse_transform([user_id]), top_n))
book_img_url = []
book_title = []
estimated_rating = []
for i in recom_idx:
    isbn = x_target_impitem[i]
    book_img_url.append(df[df['itemId'] == isbn].iloc[0]['Image-URL-M'])
    book_title.append(df[df['itemId'] == isbn].iloc[0]['Book-Title'])
    estimated_rating.append(x_target_rating[i])

i_row = 2
i_col = 5
fig, ax = plt.subplots(i_row, i_col, figsize=(14, 7))
for i, url in enumerate(book_img_url):
    img = Image.open(urlopen(url))
    ax[i // 5, i % 5].imshow(img, aspect="auto")
    ax[i // 5, i % 5].set_title(str(i+1) + ': ' + book_title[i][:15] + '...')
    ax[i // 5, i % 5].axis('off')
plt.show()

print()
for i, title in enumerate(book_title):
    print('{:2d}: rating = {:.2f}   {}'.format(i+1, estimated_rating[i] * 10, title))

# 타겟 유저가 읽지 않은 책들에 대해 해당 유저가 부여할 rating을 추정한다.
# target user가 읽은 책의 ISBN
seen_id = set(explicit[explicit['userId'] == user_id]['itemId'])

# target user가 보지 않은 movieId
unseen_id = list(set(explicit['itemId']) - seen_id)

# target user가 보지 않은 영화의 평점을 추정하기 위한 데이터 세트를 생성한다.
x_target_item = np.array(unseen_id, dtype=np.int32)
x_target_user = np.ones(shape = x_target_item.shape, dtype=np.int32) * user_id

# target user가 보지 않은 영화의 평점을 추정한다.
x_target_rating = model.predict([x_target_user, x_target_item]).reshape(-1)

# 추정 평점이 높은 상위 10개를 선택한다.
recom_idx = x_target_rating.argsort()[::-1][:top_n]

# 추천 책들의 이미지와 제목을 표시한다.
from urllib.request import urlopen
from PIL import Image, ImageOps

print('\nUser = {}의 추천 도서 목록 top-{}:\n'.format(user_enc.inverse_transform([user_id]), top_n))
book_img_url = []
book_title = []
estimated_rating = []
for i in recom_idx:
    isbn = x_target_item[i]
    book_img_url.append(explicit[explicit['itemId'] == isbn].iloc[0]['Image-URL-M'])
    book_title.append(explicit[explicit['itemId'] == isbn].iloc[0]['Book-Title'])
    estimated_rating.append(x_target_rating[i])

i_row = 2
i_col = 5
fig, ax = plt.subplots(i_row, i_col, figsize=(14, 7))
for i, url in enumerate(book_img_url):
    img = Image.open(urlopen(url))
    ax[i // 5, i % 5].imshow(img, aspect="auto")
    ax[i // 5, i % 5].set_title(str(i+1) + ': ' + book_title[i][:15] + '...')
    ax[i // 5, i % 5].axis('off')
plt.show()

print()
for i, title in enumerate(book_title):
    print('{:2d}: rating={:.2f}   {}'.format(i+1, estimated_rating[i] * 10, title))

