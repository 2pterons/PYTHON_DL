# -*- coding: utf-8 -*-
"""2-6.mnist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G2wAUJEFidBPkdFXtMYW74wGz6KPSdRD
"""

# ANN으로 mnist 데이터를 학습한다.
import matplotlib.pyplot as plt
from tensorflow.keras.datasets import mnist
from tensorflow.keras.layers import Input, Dense, Dropout
from tensorflow.keras.models import Model
from tensorflow.keras import optimizers
from sklearn.decomposition import PCA
import numpy as np

# mnist 데이터를 가져온다.
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# shape을 변경한다. 3D --> 2D
x_train = x_train.reshape(-1, 784)
x_test = x_test.reshape(-1, 784)

# target의 shape을 변경한다. 1D --> 2D
y_train = y_train.reshape(-1, 1)
y_test = y_test.reshape(-1, 1)
x_train.shape, y_train.shape

# 0 ~ 1 사잇값으로 표준화 한다.
x_train = x_train / 255
x_test = x_test / 255

# 차원축소
pc = PCA(n_components=50)
x_train_pca = pc.fit_transform(x_train)
x_test_pca = pc.transform(x_test)

# 모델
x_input = Input(batch_shape=(None, x_train_pca.shape[1]))
h_layer = Dense(64, activation='relu')(x_input)
h_layer = Dropout(rate=0.5)(h_layer)
h_layer = Dense(64, activation='relu')(x_input)
h_layer = Dropout(rate=0.5)(h_layer)
y_output = Dense(10, activation='softmax')(h_layer)

model = Model(x_input, y_output)
model.compile(loss='sparse_categorical_crossentropy', optimizer=optimizers.Adam(learning_rate=0.001))
model.summary()

hist = model.fit(x_train_pca, y_train, epochs=50, batch_size=128, validation_data=(x_test_pca, y_test))

# Loss history
plt.plot(hist.history['loss'], label='Train loss')
plt.plot(hist.history['val_loss'], label='Test loss')
plt.legend()
plt.title("Loss history")
plt.xlabel("epoch")
plt.ylabel("loss")
plt.show()

y_pred = model.predict(x_test_pca)
y_pred = np.argmax(y_pred, axis=1).reshape(-1, 1)

acc = (y_test == y_pred).mean()
print('정확도 = {:.4f}'.format(acc))

# 잘못 분류한 이미지 몇개를 확인해 본다.
# 어떤 이미지를 잘 맞추지 못할까? 사람이라면 아래 이미지를 잘 맞출 수 있을까?
n_sample = 10
miss_cls = np.where(y_test != y_pred)[0]
miss_sam = np.random.choice(miss_cls, n_sample)

fig, ax = plt.subplots(1, n_sample, figsize=(12,4))
for i, miss in enumerate(miss_sam):
    x = x_test[miss] * 255  # 표준화 단계에서 255로 나누었으므로, 여기서는 곱해준다.
    x = x.reshape(28, 28)   # 이미지 확인을 위해 (28 x 28) 형태로 변환한다.
    ax[i].imshow(x)
    ax[i].axis('off')
    ax[i].set_title(str(y_test[miss]) + ' / ' + str(y_pred[miss]))
plt.show()

